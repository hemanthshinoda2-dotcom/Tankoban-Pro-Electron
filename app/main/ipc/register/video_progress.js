// AUTO-GENERATED by Nirvana 10 split
// ========== IPC: Video Progress ==========
//
// Owns:
//   - ipcMain.handle registrations for the "videoProgress:*" request channels.
//   - Broadcasting EVENT.VIDEO_PROGRESS_UPDATED after save/clear operations.
//
// Does NOT own:
//   - The storage schema or persistence logic (lives in app/main/domains/videoProgress).
//
// Quick trace:
//   Renderer -> preload -> CHANNEL.VIDEO_PROGRESS_SAVE -> domains.videoProgress.save
//          -> EVENT.VIDEO_PROGRESS_UPDATED push

const { BrowserWindow } = require('electron');
const { EVENT } = require('../../../shared/ipc');

module.exports = function register({ ipcMain, CHANNEL, ctx, domains }) {
  // Requests
  ipcMain.handle(CHANNEL.VIDEO_PROGRESS_GET_ALL, (e, ...args) => domains.videoProgress.getAll(ctx, e, ...args));
  ipcMain.handle(CHANNEL.VIDEO_PROGRESS_GET, (e, ...args) => domains.videoProgress.get(ctx, e, ...args));

  // Save
  ipcMain.handle(CHANNEL.VIDEO_PROGRESS_SAVE, async (e, ...args) => {
    const res = await domains.videoProgress.save(ctx, e, ...args);

    // Broadcast best-effort (never let a broadcast failure break the request)
    try {
      const videoId = args && args.length ? args[0] : null;
      if (videoId) {
        const payload = {
          videoId: String(videoId),
          progress: res && res.value ? res.value : null,
        };

        for (const w of BrowserWindow.getAllWindows()) {
          if (!w || w.isDestroyed()) continue;
          w.webContents.send(EVENT.VIDEO_PROGRESS_UPDATED, payload);
        }
      }
    } catch {}

    return res;
  });

  // Clear one
  ipcMain.handle(CHANNEL.VIDEO_PROGRESS_CLEAR, async (e, ...args) => {
    const res = await domains.videoProgress.clear(ctx, e, ...args);

    try {
      const videoId = args && args.length ? args[0] : null;
      if (videoId) {
        const payload = { videoId: String(videoId), progress: null };

        for (const w of BrowserWindow.getAllWindows()) {
          if (!w || w.isDestroyed()) continue;
          w.webContents.send(EVENT.VIDEO_PROGRESS_UPDATED, payload);
        }
      }
    } catch {}

    return res;
  });

  // Clear all
  ipcMain.handle(CHANNEL.VIDEO_PROGRESS_CLEAR_ALL, async (e, ...args) => {
    const res = await domains.videoProgress.clearAll(ctx, e, ...args);

    try {
      const payload = { allCleared: true };

      for (const w of BrowserWindow.getAllWindows()) {
        if (!w || w.isDestroyed()) continue;
        w.webContents.send(EVENT.VIDEO_PROGRESS_UPDATED, payload);
      }
    } catch {}

    return res;
  });
};
